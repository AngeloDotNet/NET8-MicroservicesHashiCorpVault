using System.Text.Json;
using MassTransit;
using Microservices.Shared.Models;
using Microservices.Shared.Settings;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json.Linq;
using Vault;
using Vault.Client;
using Vault.Model;

namespace Microservices.Shared.Services;

public static class DependencyInjection
{
    public static IServiceCollection AddProducerRabbitMQ(this IServiceCollection services, RabbitMQSettings settings)
    {
        services.AddMassTransit(options =>
        {
            options.UsingRabbitMq((context, cfg) =>
            {
                cfg.Host(new Uri(settings.Hostname), h =>
                {
                    h.Username(settings.Username);
                    h.Password(settings.Password);
                });

            });
        });

        return services;
    }

    public static IServiceCollection AddConsumerRabbitMQ<Consumer>(this IServiceCollection services, RabbitMQSettings settings)
    {
        services.AddMassTransit(x =>
        {
            var consumer = typeof(Consumer).Assembly;

            x.AddConsumers(consumer);
            x.UsingRabbitMq((context, cfg) =>
            {
                cfg.Host(new Uri(settings.Hostname), h =>
                {
                    h.Username(settings.Username);
                    h.Password(settings.Password);
                });
                cfg.ReceiveEndpoint(settings.QueueReceiver, e =>
                {
                    e.ConfigureConsumers(context);
                });
            });
        });

        return services;
    }

    public static string GetConnectionDatabase(VaultSettings settings)
    {
        var vaultClient = GetVaultClient(settings);

        var mountPath = settings.MountPath;
        var secretKey = settings.SecretKey;

        if (mountPath == null)
        {
            return string.Empty;
        }

        var configDatabase = new DatabaseDTO();

        if (GetSecretKey(vaultClient, secretKey, "dbHostname", mountPath) == null)
        {
            GenerateSecretKeys(vaultClient, mountPath, secretKey);
            Thread.Sleep(100); // Sleep is necessary in order to avoid encountering the rate limit error generated by the Vault
        }

        configDatabase.DbHostname = GetSecretKey(vaultClient, secretKey, "dbHostname", mountPath);
        Thread.Sleep(100); // Sleep is necessary in order to avoid encountering the rate limit error generated by the Vault

        configDatabase.DbDatabase = GetSecretKey(vaultClient, secretKey, "dbCatalog", mountPath);
        Thread.Sleep(100); // Sleep is necessary in order to avoid encountering the rate limit error generated by the Vault

        configDatabase.DbUsername = GetSecretKey(vaultClient, secretKey, "dbUsername", mountPath);
        Thread.Sleep(100); // Sleep is necessary in order to avoid encountering the rate limit error generated by the Vault

        configDatabase.DbPassword = GetSecretKey(vaultClient, secretKey, "dbPassword", mountPath);
        Thread.Sleep(100); // Sleep is necessary in order to avoid encountering the rate limit error generated by the Vault

        return $"Data Source={configDatabase.DbHostname};Initial Catalog={configDatabase.DbDatabase};User ID={configDatabase.DbUsername};Password={configDatabase.DbPassword};Encrypt=False";
    }

    private static VaultClient GetVaultClient(VaultSettings settings)
    {
        var vaultAddress = settings.Address;
        var config = new VaultConfiguration(vaultAddress);
        var vaultClient = new VaultClient(config);

        vaultClient.SetToken(settings.Token);

        return vaultClient;
    }

    private static string GetSecretKey(VaultClient vaultClient, string secretKey, string valueRead, string mountPath)
    {
        try
        {
            var readValue = vaultClient.Secrets.KvV2Read(secretKey, mountPath);
            var result = JsonSerializer.Deserialize<object>(readValue.Data.ToJson())!.ToString();
            var response = string.Empty;

            dynamic data = JObject.Parse(result!);

            switch (valueRead)
            {
                case "dbHostname":
                    response = data.data.dbHostname;
                    break;

                case "dbCatalog":
                    response = data.data.dbCatalog;
                    break;

                case "dbUsername":
                    response = data.data.dbUsername;
                    break;

                case "dbPassword":
                    response = data.data.dbPassword;
                    break;
            }

            return response;
        }
        catch
        {
            return null!;
        }
    }

    private static bool GenerateSecretKeys(VaultClient vaultClient, string mountPath, string secretKey)
    {
        // When generating the related endpoint (issue 1), newRequest must be received as a parameter and no longer
        // hardwired into the code, so as to make its creation dynamic.
        var newRequest = new VaultDTO()
        {
            Name = secretKey,
            Data = new Dictionary<string, string>()
            {
                { "dbHostname", "hostname" },
                { "dbCatalog", "initial-catalog" },
                { "dbUsername", "username" },
                { "dbPassword", "password" }
            }
        };

        vaultClient.Secrets.KvV2Write(newRequest.Name, new KvV2WriteRequest(newRequest.Data), mountPath);
        Thread.Sleep(100); // Sleep is necessary in order to avoid encountering the rate limit error generated by the Vault

        return true;
    }
}